acid
原子性：undo log
一致性：最和兴和最本质的要就
隔离性：锁，mvcc
持久性：redo log

mvcc multi-version concurrency control
当前读：必须读取到当前数据
快照读：提高数据库的并发查询能力

三个隐式字段（DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID），undolog，readview


## 1. 范式与反范式
	第一范式：每个字段都是原子的，不能分解
	第二范式：1）表必须有主键 2）非主属性必须完全依赖，而不能部分依赖主键
	第三范式：没有传递依赖，非主属性必须直接依赖主键而不能间接依赖主键
## 2.分库分表
分布式id：snowflake雪花算法
拆分维度选择困难：
	- 建立一个映射表：映射表也要分库分表。不分表也同时写两个库。只能做一个定时任务后台比对，保证主表和映射表的数据最红一致性
	- 业务双写：多套维度方案进同时行分库分表，写入多个数据库也会导致分布式事务问题
	- 异步双写：通过binlog同步另外一套表上
	- 两个维度统一到一个维度上：订单id和用户id最为一个key进行分库
join查询问题：
	- 把join拆分成多个表查询
	- 做宽表
	- 利用搜索引擎
分布式事务：
	做了分库分表之后，春数据库的事务就不能做了。一般解决方案是优化业务，避免跨库的事务。
## 3. B+树
### 关系型数据库有以下特点：
	1）范围查询
	2）前缀匹配模糊查询
	3）排序和分页
### B+树的逻辑结构
	[[source/B+树的逻辑结构|B+树的逻辑结构]]
### 主键索引和非主键索引
	主键索引和非主键索引都会创建一个B+树，在InnoDB中，非主键索引的叶子结点存储的不是记录的指针而是主键的值。
## 4.事务
通俗的讲，事务就是一个代码块，这个代码块要么都执行要么都不执行，事务与事务之间会发生冲突。

一般有以下几类问题：

| 编号 | 问题       | 描述                                                                                                                  |
| ---- | ---------- | --------------------------------------------------------------------------------------------------------------------- |
| 1    | 脏读       | 事务A读取了一条记录值，基于这个值做了业务逻辑，在事务A提交前，事务回滚了该记录，导致事务A读取到了这条记录的一个脏数据 |
| 2    | 不可重复读 | 在一个事务里边，两次读取同一行记录，但是结果不一样，因为另外一个事物在对此记录进行了update操作                        |
| 3    | 幻读       | 在一个事务同样的select语句执行了两把，返回记录条数不同，因为另一个事务进行了insert/delete操作                         |
| 4    | 丢失更新   | 两个事务同时修改同一条数据，事务A的修改被事务B覆盖了。                                                                                                                      |

事务的隔离级别：

| 级别 | 名称                  | 解决问题                             |
| ---- | --------------------- | ------------------------------------ |
| 1    | RU（read uncommit）   | 相当于什么都没做，四个问题一个没解决 |
| 2    | RC（read commit）     | 解决 1                               |
| 3    | RR（repeatable read） | 解决123，InnoDB的默认隔离级别        |
| 4    | Serialization         | 串行化。完全解决上边四个问题                                     |

RR方式解决问题4要用到，悲观锁和乐观锁

## 5. 悲观锁和乐观锁


悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。

## 6. 事务的实现原理

### 原理1：redo log

### 原理2：undo log

### 原理3：bin log


## 7. mysql有哪些数据类型

|分类|类型名称|说明|
|---|---|---|
|**整数类型**|tinyInt|很小的整数(8位二进制)|
|smallint|小的整数(16位二进制)||
|mediumint|中等大小的整数(24位二进制)||
|int(integer)|普通大小的整数(32位二进制)||
|**小数类型**|float|单精度浮点数|
|double|双精度浮点数||
|decimal(m,d)|压缩严格的定点数||
|**日期类型**|year|YYYY1901~2155|
|time|HH:MM:SS-838:59:59~838:59:59||
|date|YYYYMM-DD1000-01-01~9999-12-3||
|datetime|YYYYMM-DDHH:MM:SS1000-01-0100:00:00~9999-12-3123:59:59||
|timestamp|YYYYMM-DDHH:MM:SS1970010100:00:01UTC~2038-01-1903:14:07UTC||
|**文本、二进制类型**|**CHAR(M)**|M为0~65535之间的整数|
|VARCHAR(M)|M为0~65535之间的整数||
|TINYBLOB|允许长度0~255字节||
|BLOB|允许长度0~65535字节||
|MEDIUMBLOB|允许长度0~167772150字节||
|LONGBLOB|允许长度0~4294967295字节||
|TINYTEXT|允许长度0~255字节||
|TEXT|允许长度0~65535字节||
|MEDIUMTEXT|允许长度0~167772150字节||
|LONGTEXT|允许长度0~4294967295字节||
|VARBINARY(M)|允许长度0~M个字节的变长字节字符串||
|BINARY(M)|允许长度0~M个字节的定长字节字符串||

**整数类型**，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。

长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNEDZEROFILL属性配合使用才有意义。

例子，假定类型设定为INT(5)，属性为UNSIGNEDZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。

**实数类型**，包括FLOAT、DOUBLE、DECIMAL。DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。 计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。

**字符串类型**，包括VARCHAR、CHAR、TEXT、BLOBVARCHAR用于存储可变长字符串，它比定长类型更节省空间。 VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。 VARCHAR存储的内容超出设置的长度时，内容会被截断。 CHAR是定长的，根据定义的字符串长度分配足够的空间。 CHAR会根据需要使用空格进行填充方便比较。 CHAR适合存储很短的字符串，或者所有值都接近同一个长度。 CHAR存储的内容超出设置的长度时，内容同样会被截断。

**使用策略：**

对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。

对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。

使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。

**枚举类型（ENUM）**，把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数

**日期和时间类型**，尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。 如果需要存储微妙，可以使用bigint存储。

看到这里，这道真题是不是就比较容易回答了。